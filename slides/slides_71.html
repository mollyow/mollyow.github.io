<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>7.1 Statistical Inference</title>
    <meta charset="utf-8" />
    <meta name="author" content="co-taught by Molly Offer-Westort &amp; Andy Eggers" />
    <meta name="author" content=".small-text[(This lecture with references to Aronow &amp; Miller (2019) and Wasserman (2004))]" />
    <script src="slides_71_files/header-attrs-2.10/header-attrs.js"></script>
    <link href="slides_71_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="slides_71_files/remark-css-0.0.1/robot.css" rel="stylesheet" />
    <link href="slides_71_files/remark-css-0.0.1/robot-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# 7.1 Statistical Inference
## PLSC30500, Fall 2021
### co-taught by Molly Offer-Westort &amp; Andy Eggers
### .small-text[(This lecture with references to Aronow &amp; Miller (2019) and Wasserman (2004))]

---




&lt;style type="text/css"&gt;
.small-output .remark-code{
  font-size: x-small;
}

# .show-only-last-code-result pre + pre:not(:last-of-type) code[class="remark-code"] {
#     display: none;
# }
&lt;/style&gt;

# Introduction to estimation


Returning to our example where we flip a coin twice, let `\(X\)` be the number of heads we observe. Our coin is *not* fair, and the probability of getting a heads is 0.8. 

--

The random variable's probability distribution is then:

$$
f(x) = \begin{cases}
1/16 &amp; x = 0 \\\
3/8 &amp; x = 1 \\\
9/16 &amp; x = 2 \\\
0 &amp; \text{otherwise}
\end{cases}
$$

---

Let's take a look at the mean. 

&lt;img src="slides_71_files/figure-html/unnamed-chunk-2-1.png" style="display: block; margin: auto;" /&gt;

--

$$
\begin{align}
\textrm{E}[X] &amp; = \sum_x x fx \\\\
&amp; = 0 \times \frac{1}{16} + 1 \times \frac{3}{8} + 2 \times \frac{9}{16}\\\
&amp; = \frac{24}{16}\\\
&amp; = 1.5
\end{align}
$$

---

And the spread.  

&lt;img src="slides_71_files/figure-html/unnamed-chunk-3-1.png" style="display: block; margin: auto;" /&gt;

Variance = average squared distance from the mean
$$
\begin{align}
\textrm{Var}[X] &amp; = \textrm{E}[(X - \textrm{E}[X)^2]\\\\
&amp; = 2.25 \times \frac{1}{16} + 0.25 \times \frac{3}{8} + 0.25 \times \frac{9}{16} \\\\
&amp; = 0.375
\end{align}
$$


---
And the spread.  

&lt;img src="slides_71_files/figure-html/unnamed-chunk-4-1.png" style="display: block; margin: auto;" /&gt;

SD = square root of variance
$$
= \sqrt{0.375} = 0.612
$$

---


We can check our calculations of the expectation and spread in R. 

--

First, we'll want to simulate the random process. We'll run the simulation a large number of times, so we'll get an accurate calculation. 


```r
n &lt;- 10000
X &lt;- c(0, 1, 2)
probs &lt;- c(1/16, 3/8, 9/16)
x.observed &lt;- replicate(sample(X, prob = probs, replace = TRUE, size = 1), n = n)

head(x.observed)
```

```
## [1] 1 0 1 1 2 2
```

--



```r
mean(x.observed)
```

```
## [1] 1.4998
```

--


```r
var(x.observed)
```

```
## [1] 0.3782378
```

```r
sd(x.observed)
```

```
## [1] 0.6150104
```

---

The process that we just did -- sampling and estimation based on observed data -- is a very common process in empirical research. 


---

# Sampling

Very often, we only observe a limited number of observations, which are drawn from a large population. 

--

We can summarize the data we observe, but we would might like to *make inferences* about the larger population--i.e., to summarize what we know about that population based on the data we observe. 

---

In our two coin flip example, suppose we don't know whether the coin is fair or not. We can observe the results of a large number of coin flips, and make an educated guess. 

--

Formally, that educated guess is called *estimation*. 

---

## Random samples

We say our data is a *random sample* if our observations are *independent and identically distributed*. 

--

Formally, if we have `\(n\)` draws, `\(X_1, \dots, X_n\)`, these draws are i.i.d. if they are independent from each other, and all have the same CDF. 

$$
X_1, \dots, X_n \sim F_X
$$

*Notational aside: `\(~\)` is read as "distributed," and means that the random variable `\(X\)` has the distribution function `\(F\)`.*

---



## Sample mean

Let's repeat our random sampling from the double coin flip, but we'll consider a smaller sample, of size `\(n = 100.\)`


```r
n &lt;- 100
x.observed &lt;- replicate(sample(X, prob = probs, replace = TRUE, size = 1), n = n)

head(x.observed)
```

```
## [1] 2 1 2 2 2 1
```

--

Our *sample mean* is the mean we observe in our data. 

`$$\bar{X}_n = \frac{X_{1} + \dots + X_n}{n} = \frac{1}{n} \sum_{i = 1}^n X_i$$`





--


```r
mean(x.observed)
```

```
## [1] 1.49
```


---

class: small-output

We differentiate the *sample mean* from the *population mean* because the sample mean will vary with every new sample we draw. 

--

We'll use a loop to see what would happen if we took a sample of size `\(n = 100\)` from the population distribution many times. 


```r
n.reps &lt;- 100

x.mat &lt;- matrix(ncol = n.reps, nrow = n)

for(i in 1:n.reps){
  x.mat[,i] &lt;- replicate(sample(X, prob = probs, replace = TRUE, size = 1), n = n)  
}
```


```r
ggplot(tibble(sample.means = colMeans(x.mat)), aes(x = sample.means)) +
  geom_histogram(bins = 25, position = 'identity', color = 'white') +
  geom_vline(xintercept = Ex, color = 'grey', lty = 'dashed')
```

&lt;img src="slides_71_files/figure-html/unnamed-chunk-11-1.png" style="display: block; margin: auto;" /&gt;


---

We see the sample means are roughly distributed around the mean of the underlying population. 


The expected value of the sample mean is the population mean. 

*See Aronow &amp; Miller for proof*. 

---
## De moivre la place theorem

---

## Sample variance

The unbiased sample variance is 

`$$S^2_n = \frac{1}{n-1}\sum_{i = 1}^n (X_i - \bar{X}_n)^2$$`
--

This looks a little bit different from the population variance formula, 

$$
\textrm{Var}[X] = \textrm{E}[(X-\textrm{E}[X)^2]
$$
--

Why do we divide by `\(n-1\)`, instead of `\(n\)`?

---

`$$S^2_n = \frac{1}{n-1}\sum_{i = 1}^n (X_i - \bar{X}_n)^2$$`

The sample mean, `\(\bar{X}_n\)`, has an expected value of `\(\textrm{E}[X]\)`. However, because it is made up of the `\(1, \dots, n\)` `\(X_i\)` that we actually observe, the expected difference between `\((X_i - \bar{X}_n)\)` is a little bit smaller than the expected difference between `\((X_i - \textrm{E}[X])\)`. 

--

To account for this, we divide by `\(n-1\)`, instead of `\(n\)`. 

---

The sample mean is itself a random variable, and so it has its own mean and variance. The mean of the sample mean is the population mean. The variance of the sample mean is:

$$
\textrm{Var}[\bar{X}] = \frac{\textrm{Var}[X]}{n}
$$


--

Let's check this in our simulation as well. We saw that mathematically, `\(\textrm{Var}[X]\)` was 0.375. So
$$
\frac{\textrm{Var}[X]}{n} = \frac{0.375}{100} = 0.00375
$$

--


```r
var(colMeans(x.mat))
```

```
## [1] 0.003746909
```


---

R has built in functions to calculate the sample mean and variance, but we can create functions of our own to check this. 






    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "atelier-lakeside-light",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
